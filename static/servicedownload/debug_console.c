#include "lig_types.h"
#include "lig_platform.h"

#include "i2c_inf.h"
#include "serial.h"

#include "si9489_drv_tpi_access.h"

#include "si9489_config.h"
#include "si9489_output.h" 
#include "si9489_switch.h"

#include "lig_queue.h"
#include "krm3000.h"

#include "debug_console.h"
#include "main.h"
/*====================================
 * Local prototypes
 *===================================*/
STATIC UCHAR *RemoveSpaces (UCHAR *Command);

STATIC void  CommandHandler (UCHAR *Command, UCHAR Len);
STATIC UCHAR HelpCommand (UCHAR *Cmd, UCHAR *Parms);
STATIC UCHAR InforCommand (UCHAR *Cmd, UCHAR *Parms);	 
STATIC UCHAR StopCommand (UCHAR *Cmd, UCHAR *Parms); 	 
STATIC UCHAR ResetCommand (UCHAR *Cmd, UCHAR *Parms);
STATIC UCHAR SwitchCommand (UCHAR *Cmd, UCHAR *Parms); 
//STATIC UCHAR SwitchaudCommand (UCHAR *Cmd, UCHAR *Parms); 
STATIC UCHAR InstaPreueveCommand (UCHAR *Cmd, UCHAR *Parms);
STATIC UCHAR OSDCommand (UCHAR *Cmd, UCHAR *Parms);	  
STATIC UCHAR LoadOSDCommand (UCHAR *Cmd, UCHAR *Parms);
STATIC UCHAR EDIDCommand (UCHAR *Cmd, UCHAR *Parms);	
STATIC UCHAR HDCPCommand (UCHAR *Cmd, UCHAR *Parms);
STATIC UCHAR I2cReadCommand (UCHAR *Cmd, UCHAR *Parms);
STATIC UCHAR I2cWriteCommand (UCHAR *Cmd, UCHAR *Parms);   
STATIC UCHAR I2cReadModifyWrite (UCHAR *Cmd, UCHAR *Parms, UCHAR Method);

STATIC UCHAR MemReadCommand (UCHAR *Cmd, UCHAR *Parms);
STATIC UCHAR MemWriteCommand (UCHAR *Cmd, UCHAR *Parms);

STATIC UCHAR *AsciiToHex (UCHAR *Strg, UCHAR *Value);
//STATIC UCHAR *AsciiToBin16 (UCHAR *Strg, UINT16 *Value);
STATIC UCHAR *HexToBinary (UCHAR *Strg, UINT32 *Value, UCHAR MaxLen);
STATIC UCHAR *AsciiToDecimal (UCHAR *Strg, UINT16 *Value);
//STATIC UCHAR *VarAsciiToHex (UCHAR *Strg, void *Value, UCHAR Length);

//STATIC UCHAR GPIOsetCommand(UCHAR *cmd, UCHAR *Parms);	 

STATIC UCHAR StartI2cLogCommand(UCHAR *Cmd, UCHAR *Parms);
STATIC UCHAR StopI2cLogCommand(UCHAR *Cmd, UCHAR *Parms);

/*====================================
 * Local variables
 *===================================*/
#define MAX_CMD_SIZE                            32

STATIC UCHAR CommandBuf[MAX_CMD_SIZE+4];
STATIC UCHAR CommandIndex = 0;

#define AAC_Allk_EDID				0
#define AC3_48k_8chs_EDID		   	1
#define ATRAC_Allk_8chs_EDID		2
#define DDPlus_EDID					3
#define DTS_Allk_EDID				4
#define DTSHD_Allk_EDID				5
#define LPCM_96_8chs_EDID			6
#define MLP_allk_EDID				7
#define MP3_Allk_EDID				8
#define MPEG1_Allk_EDID				9
#define MPEG2_Allk_EDID				10
#define No_audio_EDID				11
#define OneBitA_Allk_EDID			12

//unsigned short DB_PHA[6]={0x1000,0x2000,0x1000,0x3000,0x4000,0x5000};
unsigned short DB_PHA[6]={0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
unsigned char DB_EDID[][256] =
{
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x36, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEB 
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x16, 0x06, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84 
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x46, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDB 
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x56, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x3E, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x5E, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3 
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x0E, 0x06, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8C 
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x66, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBB
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x21, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x1E, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x29, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x03, 0x66, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDB
},
{
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x2E, 0x4D, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x0C, 0x10, 0x01, 0x03, 0x81, 0x46, 0x27, 0x78, 0xFF, 0xFF, 0x7C, 0xA3, 0x57, 0x49, 0x9C, 0x25, 
	0x11, 0x48, 0x4B, 0xFF, 0xFF, 0x80, 0x81, 0xC0, 0x81, 0x00, 0x95, 0x00, 0x81, 0x40, 0x81, 0x80, 
	0x90, 0x40, 0xB3, 0x00, 0xA9, 0x40, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1A, 0x20, 0x6E, 0x28, 
	0x55, 0x00, 0x7E, 0x88, 0x42, 0x00, 0x00, 0x1A, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 
	0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4B, 
	0x72, 0x61, 0x6D, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0A, 0x20, 0x00, 0x00, 0x00, 0xFD, 
	0x00, 0x32, 0x55, 0x1F, 0x5E, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x63, 
	0x02, 0x03, 0x1A, 0x71, 0x47, 0x11, 0x13, 0x05, 0x14, 0x84, 0x10, 0x1F, 0x23, 0x4E, 0x7F, 0x04, 
	0x83, 0x05, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 
	0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x58, 0xC2, 0x21, 0x00, 0x00, 0x18, 0x01, 0x1D, 0x80, 0x18, 
	0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 0x01, 0x1D, 
	0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x9E, 
	0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xC4, 0x8E, 0x21, 0x00, 
	0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 
	0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD3 
},
};
typedef struct
{
    CHAR *CmdName;
    CHAR *CmdHelp;
    UCHAR (*CmdHandler)(UCHAR *Cmd, UCHAR *Parms);
} UART_CMDS;

STATIC CONSTANT UART_CMDS UartCommands[] =
{
    {"?",       "Print this message",	HelpCommand},
    {"help",    "Print this message",	HelpCommand}, 	
    {"infor",   "Print useful message <type>",	InforCommand}, 
    {"pause",   "Stop <En> Main running",	StopCommand},
    {"reset",   "re running ",	ResetCommand},
	
	{"sw",      "Switch <In> <Out>",	SwitchCommand},	
//	{"asw",     "Switch aud <Rx/SPDIF> <Out>",	SwitchaudCommand},	
	{"ipv",     "Turn on <1> or Turn off <0> InstaPreueve",	InstaPreueveCommand}, 
	{"losd",     "load OSD Data to RAM",	LoadOSDCommand}, 
	{"osd",     "Turn on <1> or Turn off <0> OSD",	OSDCommand}, 
	{"edid",     "load <1> or empty to default",	EDIDCommand},  
	{"hdcp",     "load <1> dis-encryption",	HDCPCommand},
				 
    {"i2cr",    "INF i2c read <bus> <device> <register> <byte count>",	I2cReadCommand},
    {"i2cw",    "INF i2c write <bus> <device> <register> <value>",	I2cWriteCommand},

    {"memr",    "Read memory <address(32-bit aligned)>  <byte count>",	MemReadCommand},
    {"memw",    "Write memory <address(32-bit aligned)> <value>",	MemWriteCommand},
																				
    {"startlog","Start Logging I2c Transactions",	StartI2cLogCommand},
    {"stoplog", "Stop Logging I2c Transactions",	StopI2cLogCommand},	  
	
	{" ",       " ",	NULL}
};

/*====================================
 * Global variables
 *===================================*/

/*============================================================================
 *
 *
 *
 *===========================================================================*/
void UartHandlerInit (void)
{
    CommandIndex = 0;
}

/*============================================================================
 *
 *
 *
 *===========================================================================*/
void APP_UartHandler (void)
{
    UCHAR UartByte;
    BOOL ByteAvail;

    ByteAvail = ser_GetChar ((char*)&UartByte);

    while (ByteAvail)
    {
        switch (UartByte)
        {
            case 0x0D:                  /* CR */
                CommandBuf[CommandIndex] = 0;
                CommandHandler(CommandBuf, CommandIndex);
                CommandIndex=0;
                break;

            case 0x0A:                  /* LF */
                break;

            case 0x1B:                  /* ESC */
               	DBG_MSG ("\n\rCommandBuf Aborted.\n\r");
                CommandIndex = 0;
                break;
			
            case 0x08:                  /* BS */
                if (CommandIndex)
                {
                    CommandIndex--;
                }
                break;
            default:
                if ((UartByte >= 32) && (UartByte <= 127))
                {
                    if (CommandIndex < MAX_CMD_SIZE)
                    {
                        if ((UartByte >= 'A') && (UartByte <= 'Z'))
                        {
                            UartByte += 32;     /* To lower case */
                        }
                        CommandBuf[CommandIndex] = UartByte;
                        CommandIndex++;
                    }
                    else
                    {
                        DBG_MSG("\07");     /* Beep */
                    }
                }
                break;
        }
        ByteAvail = ser_GetChar ((char*)&UartByte);
    }

}

/*============================================================================
 *
 *
 *===========================================================================*/
STATIC UCHAR *RemoveSpaces (UCHAR *Command)
{
    while (*Command == ' ')
    {
        Command++;
    }
    return (Command);
}

/*============================================================================
 *
 *
 *
 *===========================================================================*/
STATIC void CommandHandler (UCHAR *Command, UCHAR CmdLen)
{
    UCHAR i=0, Len, *Cmd;

    Command = RemoveSpaces (Command);
    while (UartCommands[i].CmdHandler)
    {
        Len = strlen (UartCommands[i].CmdName);
        if (!strncmp((char *)Command, UartCommands[i].CmdName, Len))
        {
            Cmd = Command;
            if ((Cmd[Len] == 0) || (Cmd[Len] == ' '))
            {
                Command = RemoveSpaces (Cmd+Len);
                if (UartCommands[i].CmdHandler(Cmd, Command))
                {
                    DBG_MSG("Command execution failed\n\r");
                }
                break;
            }
        }
        i++;
    }
    if ((!UartCommands[i].CmdHandler) && (Command[0] >= ' '))
    {
        DBG_MSG("Unknown command\n\r");
    }
}
/*============================================================================
 *
 *
 *
 *===========================================================================*/	 
STATIC UCHAR SwitchCommand (UCHAR *Cmd, UCHAR *Parms)
{	 
    UINT16 uin0;//,uout0;	  

	Parms = AsciiToDecimal (Parms, &uin0);
	//仅输入了1组  		
	switchch(uin0);
//	DBG_MSG("Switch In=%d to Out=%d\n\r", uin0, uout0);
	return 0;
}

//STATIC UCHAR SwitchaudCommand (UCHAR *Cmd, UCHAR *Parms)
//{
//    UINT16 uin0,uout0;	  

//	Parms = AsciiToDecimal (Parms, &uin0);
//	//仅输入了1组  		
//	switchaud(uin0);
//	if (uin0==0)
//		DBG_MSG("Switch aud Rx to Out=%d\n\r", uout0);
//	else if (uin0==1)
//		DBG_MSG("Switch aud SPDIF to Out=%d\n\r", uout0);
//	else
//		DBG_MSG("Switch aud invalid\n\r");
//	return 0;
//}

STATIC UCHAR InstaPreueveCommand (UCHAR *Cmd, UCHAR *Parms)
{	
	return 0;
} 

STATIC UCHAR OSDCommand (UCHAR *Cmd, UCHAR *Parms)
{	

	return 0;
}	
STATIC UCHAR LoadOSDCommand (UCHAR *Cmd, UCHAR *Parms)
{	 
	DBG_MSG("load osd data to ram.\n\r");
	return 0;
}  
STATIC UCHAR EDIDCommand (UCHAR *Cmd, UCHAR *Parms)
{
 //   UINT16 val;	 
//    if (Parms && Parms[0])
//	{	 
// 		Parms = AsciiToDecimal (Parms, &val);
//		ConTestEDID(DB_EDID[val%13],DB_PHA);
//	}else
//	{
//		ConTestEDID(0,DB_PHA);
//	}
	return 0;	
}   
STATIC UCHAR HDCPCommand (UCHAR *Cmd, UCHAR *Parms)
{
    UINT16 val;	 
    if (Parms && Parms[0])
	{	 
 		Parms = AsciiToDecimal (Parms, &val);
		if (val==0)
		{
			ConDev.mConFollowEncrption=FE_FOLLOW_IN;
		}else if (val==1)
		{
			ConDev.mConFollowEncrption=FE_OFF_IN_HDCP;	
		}else if (val==2)
		{
			ConDev.mConFollowEncrption=FE_FORCE_DISCRP;
		}else if (val==3)
		{
			ConDev.mConFollowEncrption=FE_FORCE_ENCRP;
		}
	}
	return 0;	
}
/*============================================================================
 *
 *
 *
 *===========================================================================*/
STATIC UCHAR I2cReadCommand (UCHAR *Cmd, UCHAR *Parms)
{
    UCHAR Bus,Dev, Reg, i=1, j, k=0;
    UINT16 Count;

    Parms = AsciiToHex (Parms, &Bus);
    if (Parms && Parms[0])
    {
        Parms = AsciiToHex (Parms, &Dev);
        if (Parms && Parms[0])
        {						 	
        	Parms = AsciiToHex (Parms, &Reg);
        	if (Parms && Parms[0])
			{
	            Parms = AsciiToHex (Parms, &j);	 
	            if (Parms)
	            {
	                Count = j;
	                if (Count == 0)
	                {
	                    Count = 256;
	                }
	                while (Count)
	                {
	                    UCHAR Buf[16];
	                    memset(Buf, 0, sizeof(Buf));
	
	                    if (Count > 16)
	                    {
	                        j = 16;
	                    }
	                    else
	                    {
	                        j = (UCHAR)Count;
	                    }
						HAL_I2CReadBlock(Bus,Dev, Reg+k, Buf, j);
	                    DBG_MSG("%02x= ", Reg+k);
	                    for (i=0; i<j; i++)
	                    {
	                        DBG_MSG("0x%02x ", Buf[i]);
	                    }
	                    DBG_MSG("\n\r");
	                    k+= j;
	                    Count-= j;
	                }
	                i = 0;
	            }
			}
        }
    }
    return (i);
}

/*============================================================================
 *
 *
 *
 *===========================================================================*/
STATIC UCHAR I2cWriteCommand (UCHAR *Cmd, UCHAR *Parms)
{
    return (I2cReadModifyWrite(Cmd, Parms, 0));
}

/*============================================================================
 *
 *
 *
 *===========================================================================*/
STATIC void SwInfor(void)
{
	DBG_MSG("LOGIC SW: Tx0<-Rx%d\n\r",get_switch_out_ch(0));
	DBG_MSG("LOGIC SW: Tx1<-Rx%d\n\r",get_switch_out_ch(1));

	DBG_MSG("PYHIC SRC: Tx0<-Main(A)\n\r");
	DBG_MSG("PYHIC SRC: Tx1<-Main(A)\n\r");

	DBG_MSG("PYHIC SEL: Main(A)<-Rx%d\n\r",get_switch_in_AB(0));
	DBG_MSG("PYHIC SEL: Main(B)<-Rx%d\n\r",get_switch_in_AB(1));

//	if (OutDev[0].mOutAudSrc==0)//HDMI Rx
//		DBG_MSG("Out 0 SRC: HDMI Rx\n\r");
//	else if (OutDev[0].mOutAudSrc==1)  
//		DBG_MSG("Out 0 SRC: Extra SPDIF\n\r");	
}
STATIC void ConInfor(void)
{
	if (ConDev.mConFollowEncrption==FE_FOLLOW_IN)  
		DBG_MSG("HDCP Mode:Follow In\n\r");
	if (ConDev.mConFollowEncrption==FE_OFF_IN_HDCP)
		DBG_MSG("HDCP Mode:Off In HDCP\n\r");
	if (ConDev.mConFollowEncrption==FE_FORCE_DISCRP) 
		DBG_MSG("HDCP Mode:Force Discription\n\r");
	if (ConDev.mConFollowEncrption==FE_FORCE_ENCRP) 
		DBG_MSG("HDCP Mode:Force Encription\n\r");
	
	if (ConDev.mConAutoTxDDCCheck[0]==TRUE)
		DBG_MSG("DDC Check Mode:Auto Tx0 DDC checking\n\r");
	if (ConDev.mConAutoTxDDCCheck[0]==FALSE)
		DBG_MSG("DDC Check Mode:Disable Tx0 DDC checking\n\r");	
																  
	if (ConDev.mConAutoTxDDCCheck[1]==TRUE)
		DBG_MSG("DDC Check Mode:Auto Tx1 DDC checking\n\r");
	if (ConDev.mConAutoTxDDCCheck[1]==FALSE)
		DBG_MSG("DDC Check Mode:Disable Tx1 DDC checking\n\r");
} 
STATIC void IOVInfor(void)
{	  
	UINT8 n;
	for (n=0;n<6;n++)
	{
		if (InDev[n].mInSig==TRUE)
		{
			if (InDev[n].mInHDMI==HDMI_HDMI)
				DBG_MSG("In%d:HDMI  ",n);	
			if (InDev[n].mInHDMI==HDMI_DVI)
				DBG_MSG("In%d:DVI  ",n);
	
			if (InDev[n].mInDC==HDMI_DC_24)
				DBG_MSG("DC24  ");	   
			if (InDev[n].mInDC==HDMI_DC_30)
				DBG_MSG("DC30  ");	
			if (InDev[n].mInDC==HDMI_DC_36)
				DBG_MSG("DC36  ");	
			if (InDev[n].mInDC==HDMI_DC_48)
				DBG_MSG("DC48  ");	
	
			if (InDev[n].mInCS==HDMI_CS_RGB)
				DBG_MSG("CS-RGB  ");	
			if (InDev[n].mInCS==HDMI_CS_YUV444)
				DBG_MSG("CS-YUV444  ");
			if (InDev[n].mInCS==HDMI_CS_YUV422)
				DBG_MSG("CS-YUV422  ");
	
			if (InDev[n].mInHDCP==HDMI_IS_HDCP)
				DBG_MSG("With HDCP  "); 
			if (InDev[n].mInHDCP==HDMI_NON_HDCP)
				DBG_MSG("Without HDCP  ");
			DBG_MSG("\n\r");
		}else
		{
			DBG_MSG("In%d:No input signal\n\r",n);
		}
	}

	n=0;
	{			
		if (OutDev[n].mOutHDMI==HDMI_HDMI)
			DBG_MSG("Out%d:HDMI ",n);	
		if (OutDev[n].mOutHDMI==HDMI_DVI)
			DBG_MSG("Out%d:DVI ",n);

		if (OutDev[n].mOutDC==HDMI_DC_24)
			DBG_MSG("DC24 ");	   
		if (OutDev[n].mOutDC==HDMI_DC_30)
			DBG_MSG("DC30 ");	
		if (OutDev[n].mOutDC==HDMI_DC_36)
			DBG_MSG("DC36 ");	
		if (OutDev[n].mOutDC==HDMI_DC_48)
			DBG_MSG("DC48 ");	

		if (OutDev[n].mOutCS==HDMI_CS_RGB)
			DBG_MSG("RGB ");	
		if (OutDev[n].mOutCS==HDMI_CS_YUV444)
			DBG_MSG("YUV444 ");
		if (OutDev[n].mOutCS==HDMI_CS_YUV422)
			DBG_MSG("YUV422 ");

		if (OutDev[n].mOutHDCP==HDMI_IS_HDCP)
			DBG_MSG("With HDCP  "); 
		if (OutDev[n].mOutHDCP==HDMI_NON_HDCP)
			DBG_MSG("Without HDCP ");
		if (OutDev[n].mOutHDCP==HDMI_IS_MUTE)
			DBG_MSG("With Mute HDCP  ");						
				
		DBG_MSG("\n\r");				
	}    
}  	 
STATIC void IOAInfor(void)
{	  
	UINT8 n,m;
	for (n=0;n<6;n++)
	{
		if (InDev[n].mInSig==TRUE)
		{
			if (InDev[n].mInHDMI==HDMI_HDMI)
			{	
				DBG_MSG("In%d:",n);			
		//		if (InDev[n].mInAF==HDMI_RESERVED)
		//			DBG_MSG("AF=Res  ");
//				if (InDev[n].mInAF==HDMI_LPCM)
//					DBG_MSG("AF=LPCM  ");
//				if (InDev[n].mInAF==HDMI_AC3)
//					DBG_MSG("AF=AC3 ");
//				if (InDev[n].mInAF==HDMI_MPEG1)
//					DBG_MSG("AF=MPEG1  ");
//				if (InDev[n].mInAF==HDMI_MP3)
//					DBG_MSG("AF=MP3  ");
//				if (InDev[n].mInAF==HDMI_MPEG2)
//					DBG_MSG("AF=MPEG2  ");
//				if (InDev[n].mInAF==HDMI_AAC)
//					DBG_MSG("AF=AAC  ");
//				if (InDev[n].mInAF==HDMI_DTS)
//					DBG_MSG("AF=DTS  ");
//				if (InDev[n].mInAF==HDMI_ATRAC)
//					DBG_MSG("AF=ATRAC  ");
//				if (InDev[n].mInAF==HDMI_OBA)
//					DBG_MSG("AF=OBA  ");
//				if (InDev[n].mInAF==HDMI_DDPLUS)
//					DBG_MSG("AF=DPLUS  ");
//				if (InDev[n].mInAF==HDMI_DTSHD)
//					DBG_MSG("AF=DTSHD  ");
//				if (InDev[n].mInAF==HDMI_MAT)
//					DBG_MSG("AF=MAT ");
//				if (InDev[n].mInAF==HDMI_DST)
//					DBG_MSG("AF=DST  ");	
		
//				if (InDev[n].mInAS==HDMI_FS_INVALID)
//					DBG_MSG("AS=ReferStream  ");
//				if (InDev[n].mInAS==HDMI_Fs32)
//					DBG_MSG("AS=32  ");		  
//				if (InDev[n].mInAS==HDMI_Fs44)
//					DBG_MSG("AS=44  ");
//				if (InDev[n].mInAS==HDMI_Fs48)
//					DBG_MSG("AS=48  ");
//				if (InDev[n].mInAS==HDMI_Fs88)
//					DBG_MSG("AS=88  ");
//				if (InDev[n].mInAS==HDMI_Fs96)
//					DBG_MSG("AS=96  ");
//				if (InDev[n].mInAS==HDMI_Fs176)
//					DBG_MSG("AS=176  ");
//				if (InDev[n].mInAS==HDMI_Fs192)
//					DBG_MSG("AS=192  ");
		
//				if (InDev[n].mInAB==0)		 
//					DBG_MSG("AB=ReferStream  ");
//				else
//					DBG_MSG("AB=%d  ",InDev[n].mInAB); 
//
//				if (InDev[n].mInAC==0)
//					DBG_MSG("AC=ReferStream  ");
//				else
//					DBG_MSG("AC=%d  ",InDev[n].mInAC);	
			}else
				DBG_MSG("In%d:DVI No Audio ",n);
			DBG_MSG("\n\r");
		}else
		{
			DBG_MSG("In%d:No aud input signal\n\r",n);
		}
	}

	m=0;
	//for (m=0;m<2;m++)
	{	
		n=get_switch_out_ch(m);

		if (InDev[n].mInHDMI==HDMI_HDMI)
		{			
			DBG_MSG("In%d:",n);	

			DBG_MSG("\n\r");	
		}else			  
			DBG_MSG("In%d:DVI No Audio \n\r",n);	
	} 
} 
STATIC void SinkInfor(void)
{ 
	UINT8 n=0;
	{			  
		if (MonDev[n].mMonHPD==HPD_HIGH)
			DBG_MSG("Mon%d: HPD=H; ",n);
		else
			DBG_MSG("Mon%d: HPD=L; ",n);	 

		if (MonDev[n].mMonIsValidDDC==DDC_OK)
			DBG_MSG("DDC=OK; ");
		else
			DBG_MSG("DDC=broke; ");	
				
		if (MonDev[n].mMonMSEN==MSEN_HIGH)
			DBG_MSG("RSEN=H; ");
		else
			DBG_MSG("RSEN=L; ");
						
		if (MonDev[n].mMonHDMI==HDMI_HDMI)
			DBG_MSG("HDMI ");	
		if (MonDev[n].mMonHDMI==HDMI_DVI)
			DBG_MSG("DVI ");

		if (MonDev[n].mMonDC==HDMI_DC_24)
			DBG_MSG("DC24 ");	   
		if (MonDev[n].mMonDC==HDMI_DC_30)
			DBG_MSG("DC30 ");	
		if (MonDev[n].mMonDC==HDMI_DC_36)
			DBG_MSG("DC36 ");	
		if (MonDev[n].mMonDC==HDMI_DC_48)
			DBG_MSG("DC48 ");	

		if (MonDev[n].mMonCS==HDMI_CS_RGB)
			DBG_MSG("RGB ");	
		if (MonDev[n].mMonCS==HDMI_CS_YUV444)
			DBG_MSG("YUV444 ");
		if (MonDev[n].mMonCS==HDMI_CS_YUV422)
			DBG_MSG("YUV422 ");	  

		if (MonDev[n].mMonHDCP==CH_IS_HDCP)
			DBG_MSG("With HDCP "); 
		if (MonDev[n].mMonHDCP==CH_NON_HDCP)
			DBG_MSG("No HDCP ");
		DBG_MSG("\n\r");				
	}  
}

STATIC void PacketInfor(void)
{		   
	UINT8 n,s;
	#if 0
	for (n=0;n<6;n++)
	{
		if (InDev[n].mInSig==TRUE)
		{
			if (InDev[n].mInHDMI==HDMI_HDMI)
			{
				DBG_MSG("In%d: AVI IF[",n);				
				for (s=0;s<3;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInAvIf[s]);
				} 
				DBG_MSG("] [");
				DBG_MSG("0x%x",InDev[n].mInAvCheckSum); 
				DBG_MSG("] [");	
				for (s=4;s<AV_IF_PKT_SIZE;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInAvIf[s]);
				} 
				DBG_MSG("]\n\r");	   				
				
				DBG_MSG("In%d: AUD IF[",n);				
				for (s=0;s<3;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInAudIf[s]);
				} 
				DBG_MSG("] [");
				DBG_MSG("0x%x",InDev[n].mInAudCheckSum); 
				DBG_MSG("] [");	
				for (s=4;s<AUD_IF_PKT_SIZE;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInAudIf[s]);
				} 
				DBG_MSG("]\n\r");	   				
				
				DBG_MSG("In%d: VS IF[",n);				
				for (s=0;s<3;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInVsIf[s]);
				} 
				DBG_MSG("] [");
				DBG_MSG("0x%x",InDev[n].mInVsCheckSum); 
				DBG_MSG("] [");	
				for (s=4;s<VS_PKT_SIZE;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInVsIf[s]);
				} 
				DBG_MSG("]\n\r");	  				
				
				DBG_MSG("In%d: ACP PT[",n);				
				for (s=0;s<3;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInACPIf[s]);
				} 
				DBG_MSG("] [");
				DBG_MSG("0x%x",InDev[n].mInACPCheckSum); 
				DBG_MSG("] [");	
				for (s=4;s<ACP_PKT_SIZE;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInACPIf[s]);
				} 
				DBG_MSG("]\n\r");	  				
				
				DBG_MSG("In%d: SPD PT[",n);				
				for (s=0;s<3;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInSpdIf[s]);
				} 
				DBG_MSG("] [");
				DBG_MSG("0x%x",InDev[n].mInSpdCheckSum); 
				DBG_MSG("] [");	
				for (s=4;s<SPD_PKT_SIZE;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInSpdIf[s]);
				} 
				DBG_MSG("]\n\r");				
				
				DBG_MSG("In%d: ISRC1 PT[",n);				
				for (s=0;s<3;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInISRC1If[s]);
				} 
				DBG_MSG("] [");
				DBG_MSG("0x%x",InDev[n].mInISRC1CheckSum); 
				DBG_MSG("] [");	
				for (s=4;s<ISRC1_PKT_SIZE;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInISRC1If[s]);
				} 
				DBG_MSG("]\n\r");	 				
				
				DBG_MSG("In%d: ISRC2 PT[",n);				
				for (s=0;s<3;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInISRC2If[s]);
				} 
				DBG_MSG("] [");
				DBG_MSG("0x%x",InDev[n].mInISRC2CheckSum); 
				DBG_MSG("] [");	
				for (s=4;s<ISRC2_PKT_SIZE;s++)
				{
					DBG_MSG("0x%x ",InDev[n].mInISRC2If[s]);
				} 
				DBG_MSG("]\n\r");	 
			}else
				DBG_MSG("In%d:No input signal\n\r",n);
		}else
			DBG_MSG("In%d:No input signal\n\r",n);
	}

	n=0;

	//for (n=0;n<2;n++)
	{			
		if (OutDev[n].mOutHDMI==HDMI_HDMI)
		{			 
			DBG_MSG("Out%d: AVI IF[",n);				
			for (s=0;s<3;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutAvIf[s]);
			} 
			DBG_MSG("] [");
			DBG_MSG("0x%x",OutDev[n].mOutAvCheckSum); 
			DBG_MSG("] [");	
			for (s=4;s<AV_IF_PKT_SIZE;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutAvIf[s]);
			} 
			DBG_MSG("]\n\r");	   				
			
			DBG_MSG("Out%d: AUD IF[",n);				
			for (s=0;s<3;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutAudIf[s]);
			} 
			DBG_MSG("] [");
			DBG_MSG("0x%x",OutDev[n].mOutAudCheckSum); 
			DBG_MSG("] [");	
			for (s=4;s<AUD_IF_PKT_SIZE;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutAudIf[s]);
			} 
			DBG_MSG("]\n\r");	   				
			
			DBG_MSG("Out%d: VS IF[",n);				
			for (s=0;s<3;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutVsIf[s]);
			} 
			DBG_MSG("] [");
			DBG_MSG("0x%x",OutDev[n].mOutVsCheckSum); 
			DBG_MSG("] [");	
			for (s=4;s<VS_PKT_SIZE;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutVsIf[s]);
			} 
			DBG_MSG("]\n\r");	  				
			
			DBG_MSG("Out%d: ACP PT[",n);				
			for (s=0;s<3;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutACPIf[s]);
			} 
			DBG_MSG("] [");
			DBG_MSG("0x%x",OutDev[n].mOutACPCheckSum); 
			DBG_MSG("] [");	
			for (s=4;s<ACP_PKT_SIZE;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutACPIf[s]);
			} 
			DBG_MSG("]\n\r");	  				
			
			DBG_MSG("Out%d: SPD PT[",n);				
			for (s=0;s<3;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutSpdIf[s]);
			} 
			DBG_MSG("] [");
			DBG_MSG("0x%x",OutDev[n].mOutSpdCheckSum); 
			DBG_MSG("] [");	
			for (s=4;s<SPD_PKT_SIZE;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutSpdIf[s]);
			} 
			DBG_MSG("]\n\r");				
			
			DBG_MSG("Out%d: ISRC1 PT[",n);				
			for (s=0;s<3;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutISRC1If[s]);
			} 
			DBG_MSG("] [");
			DBG_MSG("0x%x",OutDev[n].mOutISRC1CheckSum); 
			DBG_MSG("] [");	
			for (s=4;s<ISRC1_PKT_SIZE;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutISRC1If[s]);
			} 
			DBG_MSG("]\n\r");	 				
			
			DBG_MSG("Out%d: ISRC2 PT[",n);				
			for (s=0;s<3;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutISRC2If[s]);
			} 
			DBG_MSG("] [");
			DBG_MSG("0x%x",OutDev[n].mOutISRC2CheckSum); 
			DBG_MSG("] [");	
			for (s=4;s<ISRC2_PKT_SIZE;s++)
			{
				DBG_MSG("0x%x ",OutDev[n].mOutISRC2If[s]);
			} 
			DBG_MSG("]\n\r");	 
		}else
			DBG_MSG("Out%d:DVI no packet \n\r",n);	
	} 
	#endif  	
}
STATIC UCHAR InforCommand (UCHAR *Cmd, UCHAR *Parms)
{
	UINT16 Type;
	Parms = AsciiToDecimal (Parms, &Type);  
	switch(Type)
	{
		case 0:ConInfor();break;
		case 1:IOVInfor();break;
		case 2:IOAInfor();break;
		case 3:SinkInfor();break;
		case 4:PacketInfor();break;
		case 5:SwInfor();break;	 
		case 6:break;
		default:
			DBG_MSG("Params wrong , 0=Con,1=IOV,2=IOA,3=Sink,4=PKT,5=SW,6=EDID\n\r");
			break;
	}
	return (0);
}
STATIC UCHAR HelpCommand (UCHAR *Cmd, UCHAR *Parms)
{
    UCHAR i=0;
    char Spaces[16];

    Spaces[10]=0;

    DBG_MSG("\n\rCommand   Description and parameters (All data in hex)\n\r\n\r");
    while (UartCommands[i].CmdHandler)
    {
        memset(Spaces, 0x20, 10);
        memcpy(Spaces, UartCommands[i].CmdName,strlen(UartCommands[i].CmdName));
        DBG_MSG("%s", Spaces);
        DBG_MSG("%s\n\r", UartCommands[i].CmdHelp);
        i++;
    }
    DBG_MSG("\n\r");
    return (0);
}
STATIC UCHAR ResetCommand (UCHAR *Cmd, UCHAR *Parms)
{
	SET_EVENT(EV_POWER_ON);
	DBG_MSG("reset.......\n\r"); 
    return (0);
}
STATIC UCHAR StopCommand (UCHAR *Cmd, UCHAR *Parms)
{
	UINT16 En;
	Parms = AsciiToDecimal (Parms, &En);
    if (En==1)
	{	   
		MainDev.mRunning=FALSE;
		DBG_MSG("Stop main running\n\r");
	}else
	{
		MainDev.mRunning=TRUE; 
		DBG_MSG("recover main running\n\r");	  
	}	
    return (0);
}
/*============================================================================
 *
 * Entry:   Method = 0 for None
 *                   1 for AND
 *                   2 for OR
 *                   3 for XOR
 *
 *===========================================================================*/
STATIC UCHAR I2cReadModifyWrite (UCHAR *Cmd, UCHAR *Parms, UCHAR Method)
{
    UCHAR Bus,Dev, Reg, Val, i=1;

	Parms = AsciiToHex (Parms, &Bus);
   	if (Parms && Parms[0])
	{
	    Parms = AsciiToHex (Parms, &Dev);
	    if (Parms && Parms[0])
	    {
	        Parms = AsciiToHex (Parms, &Reg);
	        if (Parms && Parms[0])
	        {
	            Parms = AsciiToHex (Parms, &Val);
	            if (Parms)
	            {
	                UCHAR ByteX = 0;
					HAL_I2CReadByte(Bus,Dev, Reg, &ByteX);

	                if (Method == 0)
	                {
	                    ByteX = Val;
	                }
	                else if (Method == 1)
	                {
	                    ByteX &= Val;
	                }
	                else if (Method == 2)
	                {
	                    ByteX |= Val;
	                }
	                else
	                {
	                    ByteX ^= Val;
	                }	   
					HAL_I2CWriteByte(Bus,Dev, Reg, ByteX);
	                DBG_MSG("0x%x Written to 0x%x:0x%x\n\r", ByteX, Dev, Reg);
	                i = 0;
	            }
	        }
	    }
	}
    return (i);
}

/*============================================================================
 *
 *
 *
 *===========================================================================*/
STATIC UCHAR MemReadCommand (UCHAR *Cmd, UCHAR *Parms)
{
    UINT32 Reg_addr=0;
    UCHAR AddrByte, Count, i;
    UCHAR RetVal = 1;

    Parms = AsciiToHex (Parms, &AddrByte);
    if (Parms && Parms[0])
    {
        Reg_addr = AddrByte;
        Parms = AsciiToHex (Parms, &AddrByte);
        if (Parms && Parms[0])
        {
            Reg_addr = (Reg_addr<<8) | AddrByte;
            Parms = AsciiToHex (Parms, &AddrByte);
            if (Parms && Parms[0])
            {
                Reg_addr = (Reg_addr<<8) | AddrByte;
                Parms = AsciiToHex (Parms, &AddrByte);
                if (Parms)
                {
                    Reg_addr = (Reg_addr<<8) | AddrByte;
                    Parms = AsciiToHex (Parms, &AddrByte);
                    RetVal = 0;
                }
            }
        }
    }

    Count = AddrByte;
    Count &= 0x1f;
    DBG_MSG("Mem Address=0x%08x,", Reg_addr);
    DBG_MSG("Num=0x%02x, Value=", Count);
    if (RetVal == 0)
    {
        for (i=0; i<Count; i++)
        {
            AddrByte = *(UCHAR*)Reg_addr;
            DBG_MSG("0x%02x ", AddrByte);
            Reg_addr++;
        }
        DBG_MSG("\n\r");
    }
    return (RetVal);
}

/*============================================================================
 *
 *
 *
 *===========================================================================*/
STATIC UCHAR MemWriteCommand (UCHAR *Cmd, UCHAR *Parms)
{
    UINT32 Reg_addr=0;
    UCHAR AddrByte, Value;
    UCHAR RetVal = 1;
 
    Parms = AsciiToHex (Parms, &AddrByte);
    if (Parms && Parms[0])
    {
        Reg_addr = AddrByte;
        Parms = AsciiToHex (Parms, &AddrByte);
        if (Parms && Parms[0])
        {
            Reg_addr = (Reg_addr<<8) | AddrByte;
            Parms = AsciiToHex (Parms, &AddrByte);
            if (Parms && Parms[0])
            {
                Reg_addr = (Reg_addr<<8) | AddrByte;
                Parms = AsciiToHex (Parms, &AddrByte);
                if (Parms)
                {
                    Reg_addr = (Reg_addr<<8) | AddrByte;
                    Parms = AsciiToHex (Parms, &AddrByte);
                    RetVal = 0;
                }
            }
        }
    }

    Value = AddrByte;
    DBG_MSG("Mem Address=0x%08x,", Reg_addr);
    DBG_MSG("Value=0x%02x\n\r", Value);
    if (RetVal == 0)
    {
        *(UCHAR*)Reg_addr = Value;
    }
    return (RetVal);
}
/*============================================================================
 *
 *
 *
 *===========================================================================*/
STATIC UCHAR *AsciiToDecimal (UCHAR *Strg, UINT16 *Value)
{
    UCHAR i, *NumEnd;
    UINT32 Val=0;

    for (i=0; i<5; i++)
    {
        if ((Strg[i] >= '0') && (Strg[i] <= '9'))
        {
            Val *= 10;
            Val += (Strg[i] - '0');
        }
        else
        {
            break;
        }
    }

    if (i && (Val < 0x10000) && ((Strg[i] == 0) || (Strg[i] == ' ') || (Strg[i] == ',')))
    {
        *Value = (UINT16)Val;
        if (Strg[i] == ',')
        {
            i++;
        }
        NumEnd = RemoveSpaces (Strg+i);
        return (NumEnd);
    }
    return (NULL);
}

/*============================================================================
 * Get the 8-bit binary value of an ASCII hex string
 *
 * Entry:   Strg   = Pointer to hex string that may or may not start with '0x'
 *          Value  = Pointer to receive binary value of hex string
 *
 * Return:  Pointer to after the end of hex string, skipping tariling ','
 *          and/or any spaces
 *          NULL if invalid hex string
 *
 *===========================================================================*/
STATIC UCHAR *AsciiToHex (UCHAR *Strg, UCHAR *Value)
{
    UINT32 Val = 0;
    UCHAR *RetVal;

    RetVal = HexToBinary (Strg, &Val, 2);
    *Value = (UCHAR)Val;
    return (RetVal);
}

/*============================================================================
 * Get the binary value of an ASCII hex string
 *
 * Entry:   Strg   = Pointer to hex string that may or may not start with '0x'
 *          Value  = Pointer to receive binary value of hex string
 *          MaxLen = Maximum allowed length of hex string, excluding the '0x'
 *
 * Return:  Pointer to after the end of hex string, skipping tariling ','
 *          and/or any spaces
 *          NULL if invalid hex string
 *
 *===========================================================================*/
STATIC UCHAR *HexToBinary (UCHAR *Strg, UINT32 *Value, UCHAR MaxLen)
{
    UCHAR i, *NumEnd;
    UINT32 Val=0;

    if ((Strg[0] == '0') && (Strg[1] == 'x'))
    {
        Strg+= 2;
    }

    for (i=0; i<MaxLen; i++)
    {
        if ((Strg[i] >= '0') && (Strg[i] <= '9'))
        {
            Val <<= 4;
            Val |= (Strg[i] - '0');
        }
        else if ((Strg[i] >= 'a') && (Strg[i] <= 'f'))
        {
            Val <<= 4;
            Val |= (Strg[i] - 'a' + 10);
        }
        else
        {
            break;
        }
    }
    if (i && ((Strg[i] == 0) || (Strg[i] == ' ') || (Strg[i] == ',')))
    {
        *Value = Val;
        if (Strg[i] == ',')
        {
            i++;
        }
        NumEnd = RemoveSpaces (Strg+i);
        return (NumEnd);
    }
    return (NULL);
}

/*============================================================================
 * Initialize all necessarily conditions
 * to log all the I2C transactions whenever there's a i2cwrite issued
 *===========================================================================*/
STATIC UCHAR StartI2cLogCommand(UCHAR *Cmd, UCHAR *Parms)
{	
    HAL_I2C_LogInit();
    return(0);	
}

/*============================================================================
 * Stop logging I2C transactions by setting the I2CLogEnabled flag to false
 *
 *===========================================================================*/
STATIC UCHAR StopI2cLogCommand(UCHAR *Cmd, UCHAR *Parms)
{
    HAL_I2C_LogStop();
    return(0);
}


 


